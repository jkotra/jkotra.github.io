<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>network programming on &lt;stdin></title><link>https://stdin.top/tags/network-programming/</link><description>Recent content in network programming on &lt;stdin></description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 20 Sep 2020 20:07:40 +0530</lastBuildDate><atom:link href="https://stdin.top/tags/network-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Parse HTTPS website(s) in C with OpenSSL</title><link>https://stdin.top/posts/https_parse_openssl/</link><pubDate>Sun, 20 Sep 2020 20:07:40 +0530</pubDate><guid>https://stdin.top/posts/https_parse_openssl/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>In this article, I will explain how to parse a website that uses &lt;code>HTTPS&lt;/code>. in the process, one must get a grip on OpenSSL and integrating it with TCP (TLS) to retrieve content.&lt;/p>
&lt;h1 id="openssl">OpenSSL&lt;/h1>
&lt;blockquote>
&lt;p>OpenSSL is a software library for applications that secure communications over computer networks against eavesdropping or need to identify the party at the other end. It is widely used by Internet servers, including the majority of HTTPS websites.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/OpenSSL">Source&lt;/a>&lt;/p>
&lt;h2 id="parsing-from-https-website">Parsing from &lt;code>HTTPS&lt;/code> website&lt;/h2>
&lt;div class="notices note" >&lt;p>the code explained here can be found in my &lt;a href="https://github.com/jkotra/NetworkProgramming/blob/master/tls/get_https_webpage.c">NetworkProgramming GitHub repository&lt;/a>.&lt;/p>&lt;/div>
&lt;h3 id="tls">TLS&lt;/h3>
&lt;blockquote>
&lt;p>Transport Layer Security, and its now-deprecated predecessor, Secure Sockets Layer, are cryptographic protocols designed to provide communications security over a computer network. Several versions of the protocols find widespread use in applications such as web browsing, email, instant messaging, and voice over IP.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Source&lt;/a>&lt;/p>
&lt;h3 id="walkthrough">Walkthrough&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;openssl/x509.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;openssl/crypto.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;openssl/pem.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;openssl/ssl.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;openssl/err.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;openssl/evp.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/socket.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/select.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;netinet/in.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;netdb.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdbool.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;errno.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We start by importing the required headers. Notice the OpenSSL headers, these contain essential functions to communicate securely with the website.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[])&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">// ssl initialization.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">SSL_library_init&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="n">OpenSSL_add_all_algorithms&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>main()&lt;/code> function takes two arguments, a domain name/ IP and a port/protocol. SSL port is &lt;code>443&lt;/code>. we can also use &lt;code>https&lt;/code>(which defaults to &lt;code>443&lt;/code>) as the port. &lt;code>getaddrinfo()&lt;/code> will understand it either way.&lt;/p>
&lt;p>we need to initialize two functions, &lt;code>SSL_library_init()&lt;/code> will set up the environment to use other functions of OpenSSL. &lt;code>OpenSSL_add_all_algorithms()&lt;/code> will load required algorithms to encrypt, decrypt data and negotiate cipher with server.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="c1">//init context
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">SSL_CTX&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ctx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SSL_CTX_new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TLS_client_method&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;cannot create SSL context!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>we then need to initialize a context using &lt;code>SSL_CTX_new()&lt;/code>. we pass a inbuilt constructor, &lt;code>TLS_client_method()&lt;/code> indicating that we expect a client functionality.&lt;/p>
&lt;div class="notices info" >&lt;p>&lt;p>&lt;code>TLS_method(), TLS_server_method(), TLS_client_method()&lt;/code>&lt;/p>
&lt;p>These are the general-purpose version-flexible SSL/TLS methods. The actual protocol version used will be negotiated to the highest version mutually supported by the client and the server. The supported protocols are SSLv3, TLSv1, TLSv1.1 and TLSv1.2. Applications should use these methods, and avoid the version-specific methods described below.&lt;/p>
&lt;p>&lt;a href="https://www.openssl.org/docs/man1.1.0/man3/TLS_client_method.html">Source&lt;/a>&lt;/p>
&lt;/p>&lt;/div>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="cm">/* code taken from tcp_client_classic.c */&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="n">hints&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">peer&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">hints&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ai_socktype&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SOCK_STREAM&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;args: %s %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">getaddrinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">peer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;addrinfo() error!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">peer_addr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">peer_protocol&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="n">getnameinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addrlen&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">peer_addr&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">peer_protocol&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">peer_protocol&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">NI_NUMERICHOST&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;ip: %s | protocol: %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer_protocol&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//family socket_type protocol
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">socket_fd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">socket&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_family&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_socktype&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_protocol&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;socket error.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addrlen&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;connect error.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;connected!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="cm">/* END */&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above code is directly taken from &lt;code>tcp_client_classic.c&lt;/code> which is explained in &lt;a href="https://stdin.top/posts/network-programming-pt2/">this article&lt;/a>.&lt;/p>
&lt;p>this essentially initiates a connection with the server, involving address resolution, socket creation, and &lt;code>connect()&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="n">SSL&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ssl&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SSL_new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ctx&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">stderr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;SSL_new() failed.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>next, we create an &lt;code>SSL&lt;/code> pointer for peer(server). this will be used to communicate with the server replacing a &lt;code>socket_fd&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">SSL_set_tlsext_host_name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ssl&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">stderr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;SSL_set_tlsext_host_name() failed.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above code will ask the server to send details only related to the required website/Hostname. This is a necessary step if multiple sites are hosted under 1(single) IP. The server will then send a certificate pertaining to the hostname provided. it&amp;rsquo;s up to us(client) to validate the details.&lt;/p>
&lt;p>Usually, a self-signed certificate cannot be trusted, every OS comes with a set of trusted CA(certificate authorities) that are to be trusted. the client also must verify that the certificate is valid and not expired or yet-to-be issued.&lt;/p>
&lt;p>(certificate validation is not covered in this article)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="n">SSL_set_fd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ssl&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">socket_fd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">SSL_connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ssl&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">stderr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;SSL_connect() failed.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the above step, we connect our TCP socket to &lt;code>SSL&lt;/code> using &lt;code>SSL_set_fd&lt;/code>. from this point onwards (after &lt;code>SSL_connect()&lt;/code>) we can communicate securely.&lt;/p>
&lt;p>&lt;code>ssl_connect()&lt;/code> negotiates the best possible and mutually accepted cipher to decrypt and encrypt.it returns &lt;code>-1&lt;/code> on error.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;SSL/TLS using %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SSL_get_cipher&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ssl&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>(Optional) print the cipher being used using &lt;code>SSL_get_cipher()&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">char&lt;/span> &lt;span class="n">buffer&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2048&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="n">sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;GET / HTTP/1.1&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;Host: %s:%s&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="n">sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;Connection: close&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;User-Agent: https_simple&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">SSL_write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ssl&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buffer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Sent Headers:&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">%s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buffer&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">bytes_received&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SSL_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ssl&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buffer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bytes_received&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">Connection closed by peer.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Received (%d bytes): &amp;#39;%.*s&amp;#39;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bytes_received&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bytes_received&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buffer&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above code&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> declares a buffer. the buffer is filled with requred HTTP headers to make a request. &lt;code>send()&lt;/code> is replaced by &lt;code>SSL_write()&lt;/code> and &lt;code>recv()&lt;/code> is replaced by &lt;code>SSL_read()&lt;/code>.&lt;/p>
&lt;p>the response is then stored into the &lt;code>buffer&lt;/code>. the response is printed onto the screen.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="c1">// shutdown ssl connection and free() ctx.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">SSL_shutdown&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ssl&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">SSL_free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ssl&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">SSL_CTX_free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ctx&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// close socket
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally, we must clean up pointers n stuff, starting with OpenSSL. shutdown the current SSL connection using &lt;code>SSL_shutdown()&lt;/code>, then free it from memory i.e &lt;code>SSL_free(ssl)&lt;/code>. SSL context that is used to create SSL should be free&amp;rsquo;d (since we are exiting the application, keep it around if you don&amp;rsquo;t). Finally, as always, close the socket using &lt;code>close()&lt;/code>&lt;/p>
&lt;h3 id="output">Output&lt;/h3>
&lt;p>compile the program with GCC (remember to link with openSSL library)&lt;/p>
&lt;p>&lt;code>gcc get_https_webpage.c -lcrypto -lssl&lt;/code>&lt;/p>
&lt;p>Run the program:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">~/Documents/Projects/network_programming/tls(master) » ./a.out example.org 443 jojo@synk
args: example.org 443
ip: 93.184.216.34 | protocol: https
connected!
SSL/TLS using TLS_AES_256_GCM_SHA384
Sent Headers:
GET / HTTP/1.1
Host: example.org:443
Connection: close
User-Agent: https_simple
Received (370 bytes): &amp;#39;HTTP/1.1 200 OK
Accept-Ranges: bytes
Age: 361373
Cache-Control: max-age=604800
Content-Type: text/html; charset=UTF-8
Date: Mon, 21 Sep 2020 18:13:25 GMT
Etag: &amp;#34;3147526947&amp;#34;
Expires: Mon, 28 Sep 2020 18:13:25 GMT
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Server: ECS (nyb/1D1B)
Vary: Accept-Encoding
X-Cache: HIT
Content-Length: 1256
Connection: close
&amp;#39;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note, the response is only partial. &lt;code>SSL_read()&lt;/code> must be run in a loop to receive until end.&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Code was taken from &lt;a href="https://github.com/codeplea/Hands-On-Network-Programming-with-C/blob/master/chap09/https_get.c">Hands-On Network Programming with C Code Repo&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Sending mail using SMTP protocol</title><link>https://stdin.top/posts/smtp-sendmail/</link><pubDate>Thu, 17 Sep 2020 00:47:17 +0530</pubDate><guid>https://stdin.top/posts/smtp-sendmail/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>This article introduces the SMTP protocol and associated code and jargon. Next, we make a quick walkthrough of code to send mail to the smtp server.&lt;/p>
&lt;h2 id="smtp-commands">SMTP commands.&lt;/h2>
&lt;p>&lt;a href="https://users.cs.cf.ac.uk/Dave.Marshall/PERL/node175.html">Read Here&lt;/a>&lt;/p>
&lt;h3 id="flow">Flow&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">(ON CONNECT) (expect 220)
HELO BOOMER (expect 250)
MAIL FROM (expect 250)
RCPT TO (expect 250)
DATA (expect 354)
(ON END OF EMAIL BODY) (expect 250)
QUIT (expect 221)
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;div class="notices note" >&lt;p>the code explained here can be found in my &lt;a href="https://github.com/jkotra/NetworkProgramming/blob/master/smtp/sendmail.c">NetworkProgramming GitHub repository&lt;/a>.&lt;/p>&lt;/div>
&lt;h1 id="sending-mail">Sending mail&lt;/h1>
&lt;p>we start by importing required headers.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/socket.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/select.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;netinet/in.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;netdb.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;ctype.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;time.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdbool.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;errno.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SMTP server address and port are &lt;code>#define&lt;/code>ed at start for ease of use later on.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define SMTPSERVER &amp;#34;gmail-smtp-in.l.google.com&amp;#34;
&lt;/span>&lt;span class="cp">#define SMTPPORT &amp;#34;25&amp;#34;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>there are 3 functions in this program:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">void parse_code(char *server_response, char *resp);
int wait_for_response(int socket_fd, char *code);
int send_response(int socket_fd, char *request);
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="parsing-code-from-a-string">Parsing code from a string&lt;/h3>
&lt;p>code parsing from the string is handled by &lt;code>parse_code&lt;/code> function.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">parse_code&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">server_response&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">resp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server_response&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">isdigit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server_response&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">isdigit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server_response&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">isdigit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server_response&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">resp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">server_response&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="n">resp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">server_response&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="n">resp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">server_response&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above function takes two parameters &lt;code>char *server_response, char *resp&lt;/code>. the result if found will be stored in &lt;code>resp&lt;/code>.&lt;/p>
&lt;h1 id="sending-and-receiving">Sending and Receiving&lt;/h1>
&lt;p>Sending and Receiving from the server is handled by two functions - &lt;code>wait_for_response&lt;/code> and &lt;code>send_response&lt;/code> respectively.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">wait_for_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">socket_fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">code&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">code_resp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">recv_bytes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">recv&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1024&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Server: %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">parse_code&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">response&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">code_resp&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">strcmp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">code_resp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">send_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">socket_fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Client: %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">sent_bytes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">send&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">request&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="main">&lt;code>main()&lt;/code>&lt;/h2>
&lt;p>we start the main function by initiating a socket.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="n">hints&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">hints&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ai_socktype&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SOCK_STREAM&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">peer_address&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">getaddrinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SMTPSERVER&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SMTPPORT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">peer_address&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">stderr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;getaddrinfo() failed.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Creating socket...&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">server&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">server&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">socket&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">peer_address&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_family&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">peer_address&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_socktype&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer_address&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_protocol&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Connecting...&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">peer_address&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer_address&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addrlen&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">stderr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;connect() failed.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">freeaddrinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">peer_address&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Connected!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above code takes care of address resolution and other things, for a detailed explanation see my posts with &lt;code>network programming&lt;/code> tag.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">wait_for_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;220&amp;#34;&lt;/span>&lt;span class="p">)){&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;unexpected response&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>on connection with SMTP server, we expect a welcome message with code &lt;code>220&lt;/code>. The program will exit if the code is mismatched.&lt;/p>
&lt;p>Example response from SMTP server:&lt;/p>
&lt;p>&lt;code>Server: 220 mx.google.com ESMTP s28si3735353pgn.104 - gsmtp&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="n">send_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;HELO BOOMER&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">wait_for_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;250&amp;#34;&lt;/span>&lt;span class="p">)){&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;unexpected response&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next, we need to identify ourself to the server, this can be done by a messagein the format of &lt;code>HELO [YOURNAME]&lt;/code>&lt;/p>
&lt;p>The SMTP server will greet us with code &lt;code>250&lt;/code> followed by a vendor-specific human greeting.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">
&lt;span class="n">send_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;MAIL FROM:&amp;lt;hekko@xyz.com&amp;gt;&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">wait_for_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;250&amp;#34;&lt;/span>&lt;span class="p">)){&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;unexpected response&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">send_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;RCPT TO:&amp;lt;testing@gmail.com&amp;gt;&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">wait_for_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;250&amp;#34;&lt;/span>&lt;span class="p">)){&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;unexpected response&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We then send the details about our ourself and the recipient. we expect a &lt;code>250&lt;/code> response from the server.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="n">send_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;DATA&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">wait_for_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;354&amp;#34;&lt;/span>&lt;span class="p">)){&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;unexpected response&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We tell the server that we are going to send email data from the next message onwards by sending it a single word &lt;code>DATA\r\n&lt;/code>. we expect the &lt;code>354&lt;/code> code in response, this indicates the server is ready to receive data.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="n">send_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;From:&amp;lt;hekko@xyz.com&amp;gt;&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">send_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;To:&amp;lt;hello@gmail.com&amp;gt;&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">send_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Subject:SMTP TEST&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>the above code will the required details in the body to the server, note that all of these can be sent in one message (headers and body) subject to server acceptance.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="n">time_t&lt;/span> &lt;span class="n">timer&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">timer&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">tm&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">timeinfo&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">timeinfo&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">gmtime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">timer&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">date&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">128&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="n">strftime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">date&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">128&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;%a, %d %b %Y %H:%M:%S +0000&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">timeinfo&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">date&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Date:%s&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">date&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">send_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">date&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">send_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>our message must include a timestamp. we generate a timestamp to include in our email using &lt;code>strftime()&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="kt">char&lt;/span> &lt;span class="n">helloworld_body&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">128&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;Hello World.&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">.&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">send_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">helloworld_body&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">wait_for_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;250&amp;#34;&lt;/span>&lt;span class="p">)){&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;unexpected response&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This the body of our mail, write your heart&amp;rsquo;s content here 😄 a simple &lt;code>.&lt;/code> separated by &lt;code>\r\n&lt;/code> will indicate that message is over.the server should return &lt;code>250&lt;/code> code.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">wait_for_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;221&amp;#34;&lt;/span>&lt;span class="p">)){&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;unexpected response&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally, we send &lt;code>QUIT\r\n&lt;/code> to the SMTP server. this formally completes our communication with the server. we then close the socket (&lt;code>server&lt;/code>)&lt;/p>
&lt;p>Congratulation, If everything works correctly, you should be able to send email using just C code.&lt;/p>
&lt;div class="notices warning" >&lt;p>Most residential IP&amp;rsquo;s are blocked to send an email. GMAIL does not allow it&amp;rsquo;s SMTP servers to be used by individuals, the email we try to send is rejected by google for obvious reasons. See output below.&lt;/p>&lt;/div>
&lt;p>Output:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">Creating socket...
Connecting...
Connected!
Server: &lt;span class="m">220&lt;/span> mx.google.com ESMTP s28si3735353pgn.104 - gsmtp
Client: HELO BOOMER
Server: &lt;span class="m">250&lt;/span> mx.google.com at your service
Client: MAIL FROM:&amp;lt;hekko@xyz.com&amp;gt;
Server: &lt;span class="m">250&lt;/span> 2.1.0 OK s28si3735353pgn.104 - gsmtp
�-�
Client: RCPT TO:&amp;lt;00.xog.00@gmail.com&amp;gt;
Server: &lt;span class="m">250&lt;/span> 2.1.5 OK s28si3735353pgn.104 - gsmtp
�-�
Client: DATA
Server: &lt;span class="m">354&lt;/span> Go ahead s28si3735353pgn.104 - gsmtp
-�
Client: From:&amp;lt;hekko@xyz.com&amp;gt;
Client: To:&amp;lt;hello@gmail.com&amp;gt;
Client: Subject:SMTP TEST
Client: Date:Date:17 Sep &lt;span class="m">2020&lt;/span> 09:31:23 +0000
Client:
Client: Hello World.
.
Server: 421-4.7.0 &lt;span class="o">[&lt;/span>223.230.89.223 15&lt;span class="o">]&lt;/span> Our system has detected that this message is
421-4.7.0 suspicious due to the very low reputation of the sending IP address.
421-4.7.0 To protect our users from spam, mail sent from your IP address has
421-4.7.0 been temporarily rate limited. Please visit
&lt;span class="m">421&lt;/span> 4.7.0 https://support.google.com/mail/answer/188131 &lt;span class="k">for&lt;/span> more information. s28si3735353pgn.104 - gsmtp
unexpected response
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>This is a very basic example of SMTP protocol which is a de facto way to send emails to each other.&lt;/p>
&lt;p>I hope you learned something in this article. A working production SMTP client would generally look like this albeit with extra nuts and bolts to handle additional security and authorization.&lt;/p></description></item><item><title>DNS resolution in C</title><link>https://stdin.top/posts/dns-resolve/</link><pubDate>Tue, 08 Sep 2020 01:20:42 +0530</pubDate><guid>https://stdin.top/posts/dns-resolve/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>DNS resolution is the process of converting Domain name (example.com) into an IP address, Reverse DNS is the opposite of it, IP -&amp;gt; Domain&lt;/p>
&lt;p>this article is a code walkthrough of a simple C program to resolve domain names into their respective IP address(s).&lt;/p>
&lt;h1 id="code">Code&lt;/h1>
&lt;div class="notices note" >&lt;p>the code explained here can be found in my &lt;a href="https://github.com/jkotra/NetworkProgramming/blob/master/dns/lookup.c">NetworkProgramming GitHub repository&lt;/a>.&lt;/p>&lt;/div>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span>&lt;span class="cpf">&amp;lt;netdb.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[]){&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;resolving host: %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="n">hints&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">hints&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ai_flags&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">AI_ALL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">peer&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">getaddrinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">peer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">){&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;getaddrinfo error!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">address&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">do&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">addr_buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="n">getnameinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addrlen&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">addr_buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">addr_buf&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">NI_NUMERICHOST&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">addr_buf&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">address&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_next&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="explanation">explanation&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>we start by first printing arguments to screen, the program expects two arguments, a domain name and a port/protocol.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>a struct of &lt;code>addrinfo&lt;/code> is declared &lt;code>hints&lt;/code>. this struct fields need to be set as per our requirement. in the next line, we set &lt;code>hints.ai_flags = AI_ALL;&lt;/code>. this means that we want bot IPV4 and IPV6 addresses. the result will be in the form of a linked list that can be iterated.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>we then declare another &lt;code>addrinfo&lt;/code> struct called &lt;code>peer&lt;/code>. this holds the results of &lt;code>getnameinfo()&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="getnameinfo">&lt;code>getnameinfo()&lt;/code>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">
&lt;span class="kt">int&lt;/span> &lt;span class="nf">getnameinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">sockaddr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">socklen_t&lt;/span> &lt;span class="n">addrlen&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">host&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">socklen_t&lt;/span> &lt;span class="n">hostlen&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">serv&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">socklen_t&lt;/span> &lt;span class="n">servlen&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;ol start="4">
&lt;li>the address(s) will be stored in a linked, there can be iterated using &lt;code>do while&lt;/code> loop as shown above in code.&lt;/li>
&lt;/ol>
&lt;h1 id="output">Output&lt;/h1>
&lt;p>compile the program using &lt;code>gcc&lt;/code>&lt;/p>
&lt;p>&lt;code>gcc lookup.c -o lookup&lt;/code>&lt;/p>
&lt;p>run the program:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">~/Documents/Projects/network_programming/dns(master*) » ./lookup example.com http jojo@synk
resolving host: example.com
93.184.216.34
93.184.216.34
93.184.216.34
2606:2800:220:1:248:1893:25c8:1946
2606:2800:220:1:248:1893:25c8:1946
2606:2800:220:1:248:1893:25c8:1946
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="notices tip" >&lt;p>&lt;p>the above output contains multiple duplicates, this can be fixed by adding another field to &lt;code>hints&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">hints&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ai_socktype&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SOCK_STREAM&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/p>&lt;/div>
&lt;hr>
&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;ul>
&lt;li>resolving domain names to IP address.&lt;/li>
&lt;li>usage of &lt;code>getnameinfo()&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>Communicating between server and client using UDP</title><link>https://stdin.top/posts/udp-server-client/</link><pubDate>Sun, 06 Sep 2020 00:34:58 +0530</pubDate><guid>https://stdin.top/posts/udp-server-client/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>This article provides a brief introduction to the UDP protocol, what makes it different from TCP. we further delve into how to set up a server and a client to communicate with each other using UDP protocol.&lt;/p>
&lt;h2 id="gentle-introduction-to-udp">Gentle introduction to UDP&lt;/h2>
&lt;blockquote>
&lt;p>UDP (User Datagram Protocol) is a communications protocol that is primarily used for establishing low-latency and loss-tolerating connections between applications on the internet. It speeds up transmissions by enabling the transfer of data before an agreement is provided by the receiving party. As a result, UDP is beneficial in time-sensitive communications, including voice over Internet Protocol (VoIP), domain name system (DNS) lookup, and video or audio playback. UDP is an alternative to Transmission Control Protocol (TCP).&lt;/p>
&lt;/blockquote>
&lt;p>Source: &lt;a href="https://searchnetworking.techtarget.com/definition/UDP-User-Datagram-Protocol">techtarget.com&lt;/a>&lt;/p>
&lt;br>
&lt;p>&lt;u>Salient features of UDP&lt;/u>:&lt;/p>
&lt;ul>
&lt;li>UDP is a called &amp;ldquo;connection-less&amp;rdquo; protocol. no prior handshake is required to send data.&lt;/li>
&lt;li>UDP has an infamous tagline &amp;ldquo;Fire and Forget&amp;rdquo;, unlike in TCP, UDP does not bother to check if the packets reached the destination or not.&lt;/li>
&lt;li>UDP is the primary protocol for DNS resolution, most DNS servers support TCP as a fallback.&lt;/li>
&lt;li>UDP is fast compared to TCP, because of the low overhead.&lt;/li>
&lt;/ul>
&lt;h1 id="udp-server">UDP Server&lt;/h1>
&lt;div class="notices note" >&lt;p>the code explained here can be found in my &lt;a href="https://github.com/jkotra/NetworkProgramming/blob/master/udp/udp_server_select.c">NetworkProgramming GitHub repository&lt;/a>.&lt;/p>&lt;/div>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="n">hints&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">bind_addr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">hints&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ai_family&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">AF_INET&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//ipv4
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">hints&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ai_socktype&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SOCK_DGRAM&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// UDP
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">hints&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ai_flags&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">AI_PASSIVE&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">getaddrinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;8080&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">bind_addr&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>we start by declaring &lt;code>addrinfo&lt;/code> struct. we set the contents of &lt;code>hints&lt;/code> to &lt;code>0&lt;/code> using &lt;code>memset()&lt;/code>&lt;/li>
&lt;li>we need to set required fields in &lt;code>hints&lt;/code>,&lt;/li>
&lt;/ol>
&lt;p>Notice the &lt;code>hints.ai_socktype&lt;/code> is set to &lt;code>SOCK_DGRAM&lt;/code>. this indicates that we want a UDP address. use &lt;code>SOCK_STREAM&lt;/code> for TCP.&lt;/p>
&lt;ol start="3">
&lt;li>we then call &lt;code>getaddrinfo()&lt;/code> with the required parameters. the result will be stored in &lt;code>bind_addr&lt;/code> struct.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="c1">//bind it
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">socket_fd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">socket&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bind_addr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_family&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bind_addr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_socktype&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bind_addr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_protocol&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;socket_fd: %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">socket_fd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bind_addr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bind_addr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addrlen&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">){&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">else&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;UDP server listing on 127.0.0.1:8080&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>create a socket. it returns a negative number on failure.&lt;/li>
&lt;li>we can then bind the address to the port, we do it by calling &lt;code>bind()&lt;/code> with socket descriptor, address, and address length.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="k">struct&lt;/span> &lt;span class="n">sockaddr_storage&lt;/span> &lt;span class="n">client_address&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">socklen_t&lt;/span> &lt;span class="n">client_len&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client_address&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">bytes_received&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">recvfrom&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1024&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sockaddr&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">client_address&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">client_len&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>declare &lt;code>sockaddr_storage&lt;/code> struct. this is used to store the address of the client.&lt;/li>
&lt;li>declare &lt;code>client_len&lt;/code> of type &lt;code>socklen_t&lt;/code>. this stores the length of the client address.&lt;/li>
&lt;li>declare a char array of length &lt;code>1024&lt;/code>.&lt;/li>
&lt;li>we then call &lt;code>recvfrom()&lt;/code>. this is where UDP defers from TCP in a major way. in UDP we do not need to call &lt;code>accept()&lt;/code> or any other handshake procedure, the data can be directly sent to the client.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="n">bytes_received&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">recvfrom&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1024&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sockaddr&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">client_address&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">client_len&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>socket_fd&lt;/code> - socket descriptor.&lt;/p>
&lt;p>&lt;code>read&lt;/code> - message buffer. the response will be stored here.&lt;/p>
&lt;p>&lt;code>1024&lt;/code> - length of &lt;code>read&lt;/code>.&lt;/p>
&lt;p>&lt;code>0&lt;/code> - Flags.&lt;/p>
&lt;p>&lt;code>(struct sockaddr*)&amp;amp;client_address&lt;/code> - client address will be stored in this on connection.&lt;/p>
&lt;p>&lt;code>&amp;amp;client_len&lt;/code> - length of client address.&lt;/p>
&lt;br>
&lt;p>we finally close the socket after reading from the client using &lt;code>close()&lt;/code>&lt;/p>
&lt;hr>
&lt;h1 id="udp-client">UDP Client&lt;/h1>
&lt;div class="notices note" >&lt;p>the code explained here can be found in my &lt;a href="https://github.com/jkotra/NetworkProgramming/blob/master/udp/udp_client.c">NetworkProgramming GitHub repository&lt;/a>.&lt;/p>&lt;/div>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[])&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">argc&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;invalid no of args.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="n">hints&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">peer&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">hints&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ai_socktype&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SOCK_DGRAM&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;args: %s %s %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">getaddrinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">peer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;addrinfo() error!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>as always, we start by declaring &lt;code>hints&lt;/code> and set required fields, in this case, we only need to set the required socket type i.e UDP &lt;code>hints.ai_socktype = SOCK_DGRAM;&lt;/code>&lt;/li>
&lt;li>we call &lt;code>getaddrinfo()&lt;/code> with user arguments, example (&lt;em>argv[1]&lt;/em> = &lt;code>example.com&lt;/code> and &lt;em>argv[2]&lt;/em> = &lt;code>80&lt;/code> or &lt;code>http&lt;/code>). result is stored in &lt;code>peer&lt;/code> struct.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="c1">//create socket
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">socket_fd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">socket&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_family&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_socktype&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_protocol&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="n">strncpy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="mi">1024&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">bytes_sent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sendto&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addrlen&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Sent %s (%d bytes)&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bytes_sent&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>create a socket.&lt;/li>
&lt;li>declare a char array of length &lt;code>1024&lt;/code> &lt;code>msg&lt;/code>.&lt;/li>
&lt;li>copy user input into &lt;code>msg&lt;/code>.&lt;/li>
&lt;li>use &lt;code>sendto()&lt;/code> to send data to the server. this works similar to &lt;code>recvfrom()&lt;/code> and is the opposite of it.&lt;/li>
&lt;li>finally close the socket using &lt;code>close()&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>&amp;ndash;&lt;/p>
&lt;h2 id="lets-chat">Let&amp;rsquo;s chat!&lt;/h2>
&lt;p>compile both server and client using &lt;code>GCC&lt;/code>&lt;/p>
&lt;p>&lt;code>gcc udp_server_select.c -o server&lt;/code>&lt;/p>
&lt;p>&lt;code>gcc udp_client.c -o client&lt;/code>&lt;/p>
&lt;ol>
&lt;li>First, run the &lt;code>server&lt;/code>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">~/Documents/Projects/network_programming/udp&lt;span class="o">(&lt;/span>master*&lt;span class="o">)&lt;/span> » ./server jojo@synk
socket_fd: &lt;span class="m">3&lt;/span>
UDP server listing on 127.0.0.1:8080
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>once the server is up and running, we can test it out by sending messages from our &lt;code>client&lt;/code>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">./client 127.0.0.1 &lt;span class="m">8080&lt;/span> hello
&lt;/code>&lt;/pre>&lt;/div>&lt;p>you should see &lt;code>hello&lt;/code> printed to in server window.&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="https://stdin.top/images/DSN1YQa.gif" alt="">
&lt;figcaption>UDP Demo&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>this article demonstrates/code walkthrough on how to set up a server and client and communicate using UDP protocol.&lt;/p></description></item><item><title>Network Programming Pt 2 - TCP client</title><link>https://stdin.top/posts/network-programming-pt2/</link><pubDate>Mon, 31 Aug 2020 01:49:14 +0530</pubDate><guid>https://stdin.top/posts/network-programming-pt2/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>HTTP is powered by TCP, websites can be retrieved by communicating through TCP socket. this a code walkthrough of c program to retrieve &lt;code>example.com&lt;/code>&lt;/p>
&lt;h1 id="tcp-client">TCP client&lt;/h1>
&lt;div class="notices note" >&lt;p>the code explained here can be found in my &lt;a href="https://github.com/jkotra/NetworkProgramming/blob/master/tcp_client_classic.c">NetworkProgramming GitHub repository&lt;/a>.&lt;/p>&lt;/div>
&lt;p>
&lt;figure>
&lt;img src="https://stdin.top/images/tcp_client.png" alt="Flowchart">
&lt;figcaption>TCP client flowchart&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="n">hints&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">peer&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">hints&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ai_socktype&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SOCK_STREAM&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;args: %s %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">getaddrinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">peer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;addrinfo() error!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>we start by declaring a &lt;code>addrinfo&lt;/code> struct &lt;code>hints&lt;/code>. we then call &lt;code>getaddrinfo()&lt;/code>. &lt;code>getaddrinfo()&lt;/code> resolves domain name into IP address.&lt;/li>
&lt;li>note that unlike in server, we only need to set &lt;code>hints.ai_socktype = SOCK_STREAM;&lt;/code> other fields are filled automatically by &lt;code>getaddrinfo()&lt;/code> based on IP we are connecting to.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="kt">char&lt;/span> &lt;span class="n">peer_addr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">peer_protocol&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="n">getnameinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addrlen&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">peer_addr&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">peer_protocol&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">peer_protocol&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">NI_NUMERICHOST&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;ip: %s | protocol: %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer_protocol&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="0">
&lt;li>we can print the domain and protocol using the code above (Optional)&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="c1">//family socket_type protocol
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">socket_fd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">socket&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_family&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_socktype&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_protocol&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;socket error.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">peer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addrlen&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;connect error.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;connected!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>we start by creating a socket using &lt;code>peer&lt;/code> fields are arguments.&lt;/li>
&lt;li>we then need to call &lt;code>connect()&lt;/code> to connect to a remote address.&lt;code>connect()&lt;/code> returns a negative number on error.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">header&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;GET /index.html HTTP/1.1&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">Host: www.example.com&lt;/span>&lt;span class="se">\r\n\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">send&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">header&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">header&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4096&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">bytes_received&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">recv&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4096&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;bytes_received: %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bytes_received&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket_fd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>declare a string &lt;strong>header&lt;/strong>, this needs to be sent to the server to get a response.&lt;/li>
&lt;li>we can then call &lt;code>recv()&lt;/code>, this stores response from the web server into &lt;code>res&lt;/code>&lt;/li>
&lt;li>the response is printed to &lt;code>stdout&lt;/code> using &lt;code>printf()&lt;/code>&lt;/li>
&lt;/ol>
&lt;h1 id="lets-test-it-out">Let&amp;rsquo;s test it out!&lt;/h1>
&lt;p>compile the program using &lt;code>gcc&lt;/code>&lt;/p>
&lt;p>&lt;code>gcc tcp_client_classic.c -o tcp_client&lt;/code>&lt;/p>
&lt;p>run the program with required args: &lt;code>domain&lt;/code> and &lt;code>protocol&lt;/code>&lt;/p>
&lt;p>&lt;code>./tcp_client example.com http&lt;/code>&lt;/p>
&lt;p>Output:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">
args: example.com http
ip: 93.184.216.34 | protocol: http
connected!
bytes_received: 1607
HTTP/1.1 200 OK
Accept-Ranges: bytes
Age: 505529
Cache-Control: max-age=604800
Content-Type: text/html; charset=UTF-8
Date: Wed, 02 Sep 2020 08:30:19 GMT
Etag: &amp;#34;3147526947&amp;#34;
Expires: Wed, 09 Sep 2020 08:30:19 GMT
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Server: ECS (nyb/1D10)
Vary: Accept-Encoding
X-Cache: HIT
Content-Length: 1256
&lt;span class="cp">&amp;lt;!doctype html&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">html&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">head&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">title&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Example Domain&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">title&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">meta&lt;/span> &lt;span class="na">charset&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;utf-8&amp;#34;&lt;/span> &lt;span class="p">/&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">meta&lt;/span> &lt;span class="na">http-equiv&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;Content-type&amp;#34;&lt;/span> &lt;span class="na">content&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;text/html; charset=utf-8&amp;#34;&lt;/span> &lt;span class="p">/&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">meta&lt;/span> &lt;span class="na">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;viewport&amp;#34;&lt;/span> &lt;span class="na">content&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;width=device-width, initial-scale=1&amp;#34;&lt;/span> &lt;span class="p">/&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">style&lt;/span> &lt;span class="na">type&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;text/css&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="nt">body&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">background-color&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mh">#f0f0f2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">margin&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">padding&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">font-family&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">apple-system&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">system-ui&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BlinkMacSystemFont&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Segoe UI&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Open Sans&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Helvetica Neue&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Helvetica&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Arial&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">sans-serif&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nt">div&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">width&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">600&lt;/span>&lt;span class="kt">px&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">margin&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="kt">em&lt;/span> &lt;span class="kc">auto&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">padding&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="kt">em&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">background-color&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mh">#fdfdff&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">border-radius&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mf">0.5&lt;/span>&lt;span class="kt">em&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">box-shadow&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="kt">px&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="kt">px&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="kt">px&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="kt">px&lt;/span> &lt;span class="nb">rgba&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mf">0.02&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nt">a&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nd">link&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nt">a&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nd">visited&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">color&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mh">#38488f&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">text-decoration&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">none&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">@&lt;/span>&lt;span class="k">media&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nt">max-width&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nt">700px&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">div&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">margin&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="kc">auto&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">width&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">auto&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">style&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">head&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">body&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">h1&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Example Domain&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">h1&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>This domain is for use in illustrative examples in documents. You may use this
domain in literature without prior coordination or asking for permission.&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;&lt;/span>&lt;span class="nt">a&lt;/span> &lt;span class="na">href&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;https://www.iana.org/domains/example&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>More information...&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">a&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;/&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">body&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">html&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>This article covered a code walkthrough on how to retrieve a web page using sockets.&lt;/p></description></item><item><title>Network programming Pt. 1 - TCP and Hello World!</title><link>https://stdin.top/posts/network-programming-pt1/</link><pubDate>Thu, 27 Aug 2020 16:40:15 +0530</pubDate><guid>https://stdin.top/posts/network-programming-pt1/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>a short introduction to &lt;a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP&lt;/a> and code walkthrough of a simple TCP web server.&lt;/p>
&lt;h2 id="tcp-protocol">TCP protocol&lt;/h2>
&lt;p>The Transmission Control Protocol (TCP) is one of the main protocols of the Internet protocol suite. It originated in the initial network implementation in which it complemented the Internet Protocol (IP). Therefore, the entire suite is commonly referred to as TCP/IP. TCP provides reliable, ordered, and error-checked delivery of a stream of octets (bytes) between applications running on hosts communicating via an IP network. Major internet applications such as the World Wide Web, email, remote administration, and file transfer rely on TCP, which is part of the Transport Layer of the TCP/IP suite. SSL/TLS often runs on top of TCP.&lt;/p>
&lt;p>Source: &lt;a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Wikipedia&lt;/a>&lt;/p>
&lt;div class="notices note" >&lt;p>TCP is a streaming protocol whereas UDP is a connectionless protocol.&lt;/p>&lt;/div>
&lt;h2 id="code">Code&lt;/h2>
&lt;div class="notices note" >&lt;p>the code explained here can be found in my &lt;a href="https://github.com/jkotra/NetworkProgramming/blob/master/hello.c">NetworkProgramming GitHub repository&lt;/a>.&lt;/p>&lt;/div>
&lt;h1 id="walkthrough">Walkthrough&lt;/h1>
&lt;p>we need a bunch of header files that contain different functions and structures that we need.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/socket.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;netinet/in.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;netdb.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdbool.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#define MAX_BACKLOG 10
&lt;/span>&lt;span class="cp">#define PORT &amp;#34;8080&amp;#34;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="header-breakdown">Header Breakdown&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Header&lt;/th>
&lt;th>what for?&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="https://pubs.opengroup.org/onlinepubs/007904975/basedefs/sys/types.h.html">sys/types.h&lt;/a>&lt;/td>
&lt;td>system types. used in cpmbination with &lt;code>sys/socket.h&lt;/code> for compatibily on all unix-like systems.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://pubs.opengroup.org/onlinepubs/007908799/xns/syssocket.h.html">sys/socket.h&lt;/a>&lt;/td>
&lt;td>&lt;code>socket(), bind(), connect(), accept(), send()&lt;/code> etc..&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://pubs.opengroup.org/onlinepubs/000095399/basedefs/netinet/in.h.html">netinet/in.h&lt;/a>&lt;/td>
&lt;td>Internet address family - structures for &lt;code>IPV4&lt;/code> &lt;code>IPV6&lt;/code> etc.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://pubs.opengroup.org/onlinepubs/007908799/xns/netdb.h.html">netdb.h&lt;/a>&lt;/td>
&lt;td>&lt;code>getaddrinfo()&lt;/code> &lt;code>getnameinfo()&lt;/code> etc..&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>
&lt;figure>
&lt;img src="https://stdin.top/images/tcp_server.png" alt="TCP server">
&lt;figcaption>TCP server flowchart&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>we start by calling &lt;code>init_server()&lt;/code> function. this function will create a socket and bind it to a port.&lt;/p>
&lt;p>&lt;code>init_server&lt;/code> return&amp;rsquo;s a socket descriptor (&lt;code>&amp;gt; 0&lt;/code>) if the socket is created and the address is successfully binded.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">
&lt;span class="kt">int&lt;/span> &lt;span class="n">socketfd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">init_server&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">socketfd&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;cannot init_server()&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>this is our &lt;code>init_server()&lt;/code> function.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">init_server&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="n">hints&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">bind_addr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">));&lt;/span> &lt;span class="c1">//zero out!
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="n">hints&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ai_family&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">AF_INET&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// we need ipv4
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">hints&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ai_socktype&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SOCK_STREAM&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// TCP
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">hints&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ai_flags&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">AI_PASSIVE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// PASSIVE mode
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="n">getaddrinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">PORT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">bind_addr&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//get local address from system.
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">//init socket
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">socketfd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">socket&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bind_addr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_family&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bind_addr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_socktype&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bind_addr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_protocol&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socketfd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bind_addr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bind_addr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ai_addrlen&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">socketfd&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>we first start by declaring two structs of &lt;code>addrinfo&lt;/code> - &lt;code>hints&lt;/code> and &lt;code>bind_addr&lt;/code>&lt;/li>
&lt;li>we must zero out the struct struct &lt;code>memset()&lt;/code>. this will remove any garbage data from it and set all friends to &lt;code>0&lt;/code>.&lt;/li>
&lt;li>set fields in &lt;code>hints&lt;/code> struct. (refer to inline comments).&lt;/li>
&lt;/ol>
&lt;div class="notices tip" >&lt;p>we only need to set &lt;code>hints.ai_socktype&lt;/code> in a &lt;strong>TCP client&lt;/strong> scenario. more on that in later parts.&lt;/p>&lt;/div>
&lt;ol start="4">
&lt;li>we then call &lt;code>getaddrinfo()&lt;/code>. it&amp;rsquo;s defined as:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">getaddrinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">service&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">hints&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">addrinfo&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">res&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>set &lt;code>NULL&lt;/code> as the first argument(&lt;em>node&lt;/em>) indicating we need an address from system, 2nd arg. is our desired port, 3rd arg is &lt;code>hints&lt;/code> struct passed as a ref, the result of this is stored in &lt;code>bind_addr&lt;/code> struct that we defined above and passed as a ref as 4th arg.&lt;/p>
&lt;ol start="5">
&lt;li>
&lt;p>we start a socket by passing the required parameters from &lt;code>bind_addr&lt;/code> struct. it will return a negative number on failure. a positive number is returned on successful creation of socket, this number indicates the file descriptor associated with the socket.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>we call &lt;code>bind()&lt;/code>. this will bind the IP to port. &lt;code>bind()&lt;/code> returns a negative number on failure.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>finally we return the &lt;code>socket_fd&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Back to &lt;code>main()&lt;/code>
we then call &lt;code>listen()&lt;/code> with two arguments, 1st arg is &lt;code>socket_fd&lt;/code> and second one is &lt;code>MAX_BACKLOG&lt;/code> - this is the maximum number of simultanious connection that our socket will accept before refusing.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//start listining
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">listen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socketfd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">MAX_BACKLOG&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;✅ server listining on 127.0.0.1:%s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">PORT&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;❌ cannot listen()! %d &lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">listen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socketfd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">MAX_BACKLOG&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>we then call to &lt;code>accept_and_send()&lt;/code> function with &lt;code>socket_fd&lt;/code> as arg. this function will accept incoming connections (forwarded by &lt;code>listen()&lt;/code>)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">accept_and_send&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socketfd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>accept_and_send()&lt;/code> function:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">accept_and_send&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">socketfd&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">sockaddr_storage&lt;/span> &lt;span class="n">client_addr&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//to store client addr
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">socklen_t&lt;/span> &lt;span class="n">client_addr_len&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//length of client addr;
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">client&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">accept&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socketfd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sockaddr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">client_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">client_addr_len&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;cannot accept connection from client!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">addr_buffer&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">//empty buf. to store ip.
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="n">getnameinfo&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sockaddr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">client_addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">client_addr_len&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">addr_buffer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">addr_buffer&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">NI_NUMERICHOST&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;client IP: %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">addr_buffer&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// HANDLE / READ REQ
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">request&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">bytes_received&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">recv&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">request&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1024&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//send response
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">response&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;HTTP/1.1 200 OK&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;Connection: close&lt;/span>&lt;span class="se">\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;Content-Type: text/plain&lt;/span>&lt;span class="se">\r\n\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;Hello World from hello.c&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">bytes_sent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">send&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">response&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>
&lt;p>we start the function by declaring two structs - &lt;code>client_addr&lt;/code> and &lt;code>client_addr_len&lt;/code>
&lt;code>sockaddr_storage&lt;/code> stores the client address. &lt;code>client_addr_len&lt;/code> stores lenth of client address.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>we call &lt;code>accept()&lt;/code>. this will accept the client connection and store the details in above-declared structs.it returns &lt;code>-1&lt;/code> on failure. this returns a file descriptor for the accepted socket that we can use to send and receive data from the client.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>optionally, we can get ip address of client using &lt;code>getnameinfo()&lt;/code>. &lt;code>getnameinfo()&lt;/code> is essentially inverse of &lt;code>getaddrinfo()&lt;/code>.&lt;/p>
&lt;ol start="4">
&lt;li>
&lt;p>TCP connection is initiated by receiving data from the client. this acts as a handshake between client and server.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>we can then send data to the client, we use &lt;code>send()&lt;/code>. to send data to the client.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>close the connection by closing the client file descriptor.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="notices tip" >&lt;p>&lt;p>it&amp;rsquo;s always a good practice to close socket at end of program.&lt;/p>
&lt;p>&lt;code>close(socket_fd)&lt;/code>&lt;/p>
&lt;/p>&lt;/div>
&lt;h1 id="lets-test-it-out">Let&amp;rsquo;s test it out!&lt;/h1>
&lt;p>compile the program using &lt;code>gcc&lt;/code>&lt;/p>
&lt;p>&lt;code>gcc hello.c -o hello&lt;/code>&lt;/p>
&lt;p>Run the program&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">~/Documents/Projects/network_programming » ./hello
socketfd = 3
✅ server listining on 127.0.0.1:8080
&lt;/code>&lt;/pre>&lt;/div>&lt;p>open a browser and navigate to &lt;code>http://127.0.0.1:8080/&lt;/code>&lt;/p>
&lt;p>you should see a nice message from our webserver:&lt;/p>
&lt;p>&lt;code>Hello World from hello.c&lt;/code>&lt;/p>
&lt;hr>
&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>My humble attempt to re-explain network programming concepts and code in C as I learn them myself, I hope this series helps in your learning and also serves as a note-keeping for me 😊&lt;/p></description></item></channel></rss>